"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

annual_income = {
    'сургутнефтегаз': 1537,
    'ростех': 1643,
    'лукойл': 7479,
    'роснефть': 6850,
    'газпром': 8224,
    'сбербанк': 3160,
    'ржд': 2413,
    'ВТБ': 1361,
    'x5 retail group': 1533
}

# Вариант 1 - сортировка с последующим выводом элементов
def sort_search_min(lst):
    for i in range(len(lst)):
        min_elem_idx = i
        for j in range(i+1, len(lst)):
            if lst[j][1] > lst [min_elem_idx][1]:
                min_elem_idx = j
        lst[i], lst[min_elem_idx] = lst[min_elem_idx], lst[i]
    return lst[0:3]

lst = list(annual_income.items())
for i in sort_search_min(lst):
    print(i[0], ':', i[1])

# Сложность, по аналогии с предыдущим заданием, квадратичная, O(n^2)

# Ваариант 2 - больше понравился вариант со словарём из разбора дз

def big_three(dict):
    input_max = {}
    for i in range(3):
        maximum = max(dict.items(), key = lambda k_v: k_v[1])
        del dict[maximum[0]]
        input_max[maximum[0]] = maximum[1]
    return input_max

print(big_three(annual_income))

# Здесь алгоритм с линейной сложностью O(n), он же лучший, так как
# самый простой и лаконичный, без лишних сортировок и прогонов циклов